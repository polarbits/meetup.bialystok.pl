'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _debug = require('../utils/debug');

var _debug2 = _interopRequireDefault(_debug);

var _spinner = require('./helpers/spinner');

var _createInstance = require('./helpers/create-instance');

var _socket = require('./helpers/socket');

var _printTools = require('../utils/print-tools');

var _dateUtils = require('../utils/date-utils');

var _errors = require('../utils/errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('cmd-socket-deploy');

const pendingUpdates = {};
const timer = new _dateUtils.Timer();

class SocketDeployCmd {
  constructor(context) {
    this.context = context;
    this.session = context.session;
    this.Socket = context.Socket;
    this.registry = new context.Registry();
    this.init = new context.Init();
    this.firstRun = true;
  }

  run([socketName, cmd]) {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.cmd = cmd;

      // echo(2)(`♻️ ${format.grey(' Deploying...')}`);

      // Create Instance if --create-instance provided
      if (cmd.createInstance) {
        yield (0, _createInstance.createInstance)(cmd.createInstance);
        yield _this.init.addConfigFiles({ instance: cmd.createInstance });
      } else {
        // If not, we have to check if we have a project attached to any instance
        _this.session.hasProject();
      }

      if (socketName) {
        debug(`Deploying Socket: ${socketName}`);
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        _this.socketList = yield _this.Socket.flatList(socketName);
        const socket = _lodash2.default.find(_this.socketList, { name: socketName });
        spinner.stop();

        if (!(socket.existLocally || socket.isProjectRegistryDependency || socket.isDependencySocket)) {
          (0, _printTools.echo)();
          (0, _printTools.error)(4)(`Socket ${_chalk2.default.cyan(socketName)} cannot be found!`);
          (0, _printTools.echo)();
          process.exit(1);
        }
      } else {
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        _this.socketList = yield _this.Socket.flatList();
        spinner.stop();
      }

      const configs = {};

      try {
        yield _bluebird2.default.each(_this.socketList, (() => {
          var _ref = _asyncToGenerator(function* (socketFromList) {
            const config = yield (0, _socket.askQuestions)(socketFromList.getConfigOptionsToAsk());
            configs[socketFromList.name] = config;
          });

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        })());
        yield _this.deployProject();

        let index;
        for (index in _this.socketList) {
          const socket = _this.socketList[index];
          yield _this.deploySocket(socket, configs[socket.name]);
        }

        (0, _printTools.echo)();
      } catch (err) {
        if (err.response && err.response.data && err.response.data.detail) {
          (0, _printTools.error)(4)(err.response.data.detail);
        } else {
          (0, _printTools.error)(4)(err);
        }
        process.exit(1);
      }
    })();
  }

  deployProject() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      timer.reset();
      const msg = (0, _printTools.p)(4)(`${_chalk2.default.magenta('project deploy:')} ${(0, _dateUtils.currentTime)()}`);
      const spinner = new _spinner.SimpleSpinner(msg).start();
      yield _this2.session.deployProject();
      spinner.stop();
      const status = _chalk2.default.grey('project synced:');
      const duration = timer.getDuration();
      (0, _printTools.echo)(5)(`${status} ${(0, _dateUtils.currentTime)()} ${duration}`);
    })();
  }

  deploySocket(socket, config) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      debug(`deploySocket: ${socket.name}`);
      const deployTimer = new _dateUtils.Timer();
      const msg = (0, _printTools.p)(4)(`${_chalk2.default.magenta('socket deploy:')} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}`);
      const spinner = new _spinner.SimpleSpinner(msg).start();

      // We have co count here updates
      if (!pendingUpdates[socket.name]) {
        pendingUpdates[socket.name] = 0;
      }

      pendingUpdates[socket.name] += 1;
      if (pendingUpdates[socket.name] > 1) {
        spinner.stop();
        _this3.mainSpinner.start();
        debug(`not updating, update pending: ${pendingUpdates[socket.name]}`);
        return;
      }

      // Let's compile and update if it is not hot mode
      try {
        const updateStatus = yield socket.update({ config, withCompilation: true, updateSocketNPMDeps: true, updateEnv: true });
        spinner.stop();
        SocketDeployCmd.printUpdateSuccessful(socket.name, updateStatus, deployTimer);
        if (updateStatus.status !== 0 && _this3.cmd.bail) {
          SocketDeployCmd.bail();
        }
      } catch (err) {
        debug(err);
        spinner.stop();
        if (err instanceof _errors.CompileError) {
          const status = _chalk2.default.red('    compile error:');
          if (err.traceback) {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}\n\n${err.traceback.split('\n').map(function (line) {
              return (0, _printTools.p)(8)(line);
            }).join('\n')}`);
          } else {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)} Error while executing 'build' script!`);
          }
        } else {
          const status = _chalk2.default.red('socket sync error:');
          if (err.message) {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)} ${_chalk2.default.red(err.message)}`);
          } else {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}`);
            (0, _printTools.error)(err);
          }
        }

        if (_this3.cmd.bail) {
          SocketDeployCmd.bail();
        }
      }
    })();
  }

  getSocketToUpdate(fileName) {
    return this.localSockets.find(socket => socket.isSocketFile(fileName));
  }

  static bail() {
    (0, _printTools.echo)();
    process.exit(1);
  }

  static printUpdateSuccessful(socketName, updateStatus, deployTimer) {
    debug('printUpdateSuccessful', socketName, updateStatus);
    const duration = _chalk2.default.dim(deployTimer.getDuration());
    const socketNameStr = `${_chalk2.default.cyan(socketName)}`;

    if (updateStatus.status === 'ok') {
      const status = _chalk2.default.grey('socket synced:');
      (0, _printTools.echo)(6)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'stopped') {
      const status = _chalk2.default.grey('socket in sync:');
      (0, _printTools.echo)(5)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'error') {
      const errDetail = _chalk2.default.red(updateStatus.message.error);
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration} ${errDetail}`);
    } else {
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    }
  }
}
exports.default = SocketDeployCmd;
module.exports = exports['default'];
//# sourceMappingURL=socket-deploy.js.map
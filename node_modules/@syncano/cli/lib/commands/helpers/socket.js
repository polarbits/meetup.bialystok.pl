'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.socketNotFound = exports.updateConfig = exports.updateSocket = exports.askQuestions = undefined;

var _inquirer = require('inquirer');

var _inquirer2 = _interopRequireDefault(_inquirer);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _debug = require('../../utils/debug');

var _debug2 = _interopRequireDefault(_debug);

var _printTools = require('../../utils/print-tools');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('cmd-helpers-socket');

const askQuestions = exports.askQuestions = configOptions => {
  const questions = [];

  Object.keys(configOptions).forEach(paramName => {
    const param = configOptions[paramName];
    const longDesc = param.long_description ? param.long_description.split('\n').join('\n    ') : ' ';
    let shortDesc = _chalk2.default.bold(paramName);
    if (param.description) {
      shortDesc = `${_chalk2.default.bold(param.description)} ${_chalk2.default.dim(`(${paramName})`)}`;
    }
    questions.push({
      name: paramName,
      message: [(0, _printTools.p)(2)(shortDesc), (0, _printTools.p)(4)(_chalk2.default.reset(longDesc)), (0, _printTools.p)(4)('Type in value:')].join('\n'),
      default: param.default,
      validate: value => {
        if (param.required && !value) {
          return 'This config value is required!';
        }
        return true;
      }
    });
  });

  return _inquirer2.default.prompt(questions);
};

const updateSocket = exports.updateSocket = (() => {
  var _ref = _asyncToGenerator(function* (socket, config) {
    debug(`updateSocket: ${socket.name}`);
    const startTime = new Date().getTime();

    try {
      const updateStatus = yield socket.update({ config });
      const endTime = new Date().getTime();
      if (updateStatus.status === 'ok') {
        (0, _printTools.echon)(4)(`${_chalk2.default.green('✓')} ${_chalk2.default.cyan(socket.name)} `);
        (0, _printTools.echo)(`successfully updated ${_chalk2.default.dim(endTime - startTime, 'ms')}`);
      } else if (updateStatus.status === 'stopped') {
        (0, _printTools.echon)(4)(`${_chalk2.default.green('✓')} ${_chalk2.default.cyan(socket.name)} `);
        (0, _printTools.echo)(`successfully updated ${_chalk2.default.dim(endTime - startTime, 'ms')}`);
      } else {
        (0, _printTools.echon)(4)(`${_chalk2.default.red('✗')} ${_chalk2.default.cyan(socket.name)} `);
        (0, _printTools.echo)(`update failed ${_chalk2.default.dim(endTime - startTime, 'ms')}`);
        const errMsg = updateStatus.message.error;
        const lineNo = updateStatus.message.lineno;
        (0, _printTools.echon)(4)(_chalk2.default.dim.red(errMsg));
        if (lineNo) {
          (0, _printTools.echo)(_chalk2.default.dim(`line ${lineNo} of socket.yml`));
        } else {
          (0, _printTools.echo)();
        }
        (0, _printTools.echo)();
      }
      return updateStatus;
    } catch (err) {
      (0, _printTools.error)(err);
    }
  });

  return function updateSocket(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

const updateConfig = exports.updateConfig = (() => {
  var _ref2 = _asyncToGenerator(function* (socket, config) {
    (0, _printTools.echo)();
    (0, _printTools.echon)(4)(`Updating Socket's ${_chalk2.default.cyan(socket.name)} config... `);

    try {
      const updateStatus = yield socket.update({ config });
      if (updateStatus === 'ok') {
        (0, _printTools.echo)(_chalk2.default.green('Done'));
        (0, _printTools.echo)();
      } else {
        (0, _printTools.echo)();
        (0, _printTools.error)(4)(updateStatus);
        (0, _printTools.echo)();
      }
    } catch (err) {
      if (typeof err === 'object' && err.errorType) {} else {
        (0, _printTools.error)(err);
      }
    }
  });

  return function updateConfig(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

const socketNotFound = exports.socketNotFound = () => {
  (0, _printTools.echo)();
  (0, _printTools.warning)(4)('No Socket was found on server nor in config!');
  (0, _printTools.echo)();
};
//# sourceMappingURL=socket.js.map
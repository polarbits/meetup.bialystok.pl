'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _watchr = require('watchr');

var _watchr2 = _interopRequireDefault(_watchr);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _debug = require('../utils/debug');

var _debug2 = _interopRequireDefault(_debug);

var _spinner = require('./helpers/spinner');

var _socket = require('./helpers/socket');

var _printTools = require('../utils/print-tools');

var _dateUtils = require('../utils/date-utils');

var _socketTrace = require('./socket-trace');

var _socketTrace2 = _interopRequireDefault(_socketTrace);

var _errors = require('../utils/errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('cmd-socket-deploy');

const pendingUpdates = {};
const timer = new _dateUtils.Timer();

class SocketDeployCmd {
  constructor(context) {
    this.context = context;
    this.session = context.session;
    this.Socket = context.Socket;
    this.registry = new context.Registry();
    this.firstRun = true;

    this.mainSpinner = new _spinner.GlobalSpinner((0, _printTools.p)(3)(`${_chalk2.default.grey('waiting...')}`));
  }

  run([socketName, cmd]) {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.cmd = cmd;

      (0, _printTools.echo)(2)(`ðŸ”¥ ${_chalk2.default.grey(' Hot deploy started')} ${_chalk2.default.dim('(Hit Ctrl-C to stop)')}`);
      (0, _printTools.echo)();

      if (socketName) {
        debug(`Deploying Socket: ${socketName}`);
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        _this.socketList = yield _this.Socket.flatList(socketName);
        const socket = _lodash2.default.find(_this.socketList, { name: socketName });
        spinner.stop();

        if (!(socket.existLocally || socket.isProjectRegistryDependency || socket.isDependencySocket)) {
          (0, _printTools.echo)();
          (0, _printTools.error)(4)(`Socket ${_chalk2.default.cyan(socketName)} cannot be found!`);
          (0, _printTools.echo)();
          process.exit(1);
        }
      } else {
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        _this.socketList = yield _this.Socket.flatList();
        spinner.stop();
      }

      const configs = {};

      _bluebird2.default.each(_this.socketList, function (socketFromList) {
        return (0, _socket.askQuestions)(socketFromList.getConfigOptionsToAsk()).then(function (config) {
          configs[socketFromList.name] = config;
        });
      }).then(function () {
        return _this.deployProject();
      }).then(function (projectUpdateStatus) {
        return _bluebird2.default.all(_this.socketList.map(function (socket) {
          return _this.deploySocket(socket, configs[socket.name]);
        }));
      }).then(function () {
        debug('Starting stalker');
        _this.runStalker();
        _this.mainSpinner.queueSize += 1;
        _this.mainSpinner.queueSize += _this.socketList.length;
        _this.mainSpinner.start();

        if (cmd.trace) {
          const traces = new _socketTrace2.default(_this.context, _this.mainSpinner);
          _bluebird2.default.all(_this.socketList.map(function (socket) {
            return traces.startCollectingTraces(socket);
          }));
        }
      }).catch(function (err) {
        if (err.response && err.response.data && err.response.data.detail) {
          (0, _printTools.error)(4)(err.response.data.detail);
        } else {
          (0, _printTools.error)(4)(err);
        }
      });
    })();
  }

  deployProject() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      timer.reset();
      const msg = (0, _printTools.p)(4)(`${_chalk2.default.magenta('project deploy:')} ${(0, _dateUtils.currentTime)()}`);
      const spinner = new _spinner.SimpleSpinner(msg).start();
      yield _this2.session.deployProject();
      spinner.stop();
      const status = _chalk2.default.grey('project synced:');
      const duration = timer.getDuration();
      (0, _printTools.echo)(5)(`${status} ${(0, _dateUtils.currentTime)()} ${duration}`);
    })();
  }

  deploySocket(socket, config) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      debug(`deploySocket: ${socket.name}`);
      const deployTimer = new _dateUtils.Timer();
      const msg = (0, _printTools.p)(4)(`${_chalk2.default.magenta('socket deploy:')} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}`);
      _this3.mainSpinner.stop();
      const spinner = new _spinner.SimpleSpinner(msg).start();

      // We have to count here number of updates
      if (!pendingUpdates[socket.name]) {
        pendingUpdates[socket.name] = 0;
      }

      pendingUpdates[socket.name] += 1;
      if (pendingUpdates[socket.name] > 1) {
        spinner.stop();
        _this3.mainSpinner.start();
        debug(`not updating, update pending: ${pendingUpdates[socket.name]}`);
        return;
      }

      const updateEnds = (() => {
        var _ref = _asyncToGenerator(function* () {
          _this3.mainSpinner.start();
          // After update we have to understand if we should fire new one
          pendingUpdates[socket.name] -= 1;
          if (pendingUpdates[socket.name] > 0) {
            pendingUpdates[socket.name] = 0;
            yield _this3.deploySocket(socket, config);
          }
        });

        return function updateEnds() {
          return _ref.apply(this, arguments);
        };
      })();

      try {
        const updateStatus = yield socket.update({ config });

        spinner.stop();
        SocketDeployCmd.printUpdateSuccessful(socket.name, updateStatus, deployTimer);
        yield updateEnds();
      } catch (err) {
        spinner.stop();
        if (err instanceof _errors.CompileError) {
          const status = _chalk2.default.red('    compile error:');
          (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}\n\n${err.traceback.split('\n').map(function (line) {
            return (0, _printTools.p)(8)(line);
          }).join('\n')}`);
        } else {
          const status = _chalk2.default.red('socket sync error:');
          (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)} ${_chalk2.default.red(err.message)}`);
        }

        if (_this3.cmd.bail) {
          SocketDeployCmd.bail();
        }
        updateEnds();
        spinner.stop();
      }
    })();
  }

  deployComponent(component) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const componentName = component.packageName;
      debug(`deployComponent: ${componentName}`);
      const deployTimer = new _dateUtils.Timer();
      const msg = (0, _printTools.p)(`${_chalk2.default.magenta('component build:')} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(componentName)}`);
      _this4.mainSpinner.stop();
      const spinner = new _spinner.SimpleSpinner(msg).start();

      // We have to count here number of updates
      if (!pendingUpdates[componentName]) {
        pendingUpdates[componentName] = 0;
      }

      pendingUpdates[componentName] += 1;
      if (pendingUpdates[componentName] > 1) {
        spinner.stop();
        _this4.mainSpinner.start();
        debug(`not updating, update pending: ${pendingUpdates[componentName]}`);
        return;
      }

      const updateEnds = (() => {
        var _ref2 = _asyncToGenerator(function* () {
          _this4.mainSpinner.start();
          // After update we have to understand if we should fire new one
          pendingUpdates[componentName] -= 1;
          if (pendingUpdates[componentName] > 0) {
            pendingUpdates[componentName] = 0;
            yield _this4.deployComponent(component);
          }
        });

        return function updateEnds() {
          return _ref2.apply(this, arguments);
        };
      })();

      try {
        yield component.build();

        spinner.stop();
        SocketDeployCmd.printUpdateSuccessful(componentName, { status: 'ok' }, deployTimer);
        yield updateEnds();
      } catch (err) {
        spinner.stop();
        if (err instanceof _errors.CompileError) {
          const status = _chalk2.default.red('    build error:');
          (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(componentName)}\n\n${err.traceback.split('\n').map(function (line) {
            return (0, _printTools.p)(8)(line);
          }).join('\n')}`);
        } else {
          const status = _chalk2.default.red('build error:');
          (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(componentName)} ${_chalk2.default.red(err.message)}`);
        }

        if (_this4.cmd.bail) {
          SocketDeployCmd.bail();
        }
        updateEnds();
        spinner.stop();
      }
    })();
  }

  getSocketToUpdate(fileName) {
    if (fileName.match(/\/test\//) || fileName.match(/\/components\//)) {
      return false;
    }
    return this.localSockets.find(socket => socket.isSocketFile(fileName));
  }

  getComponentToUpdate(fileName) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const sockets = yield _this5.Socket.listLocal();
      const componentsList = [];
      yield _bluebird2.default.all(sockets.map((() => {
        var _ref3 = _asyncToGenerator(function* (socket) {
          const components = yield _this5.Socket.getLocal(socket).getComponents();
          components.forEach(function (component) {
            componentsList.push(component);
          });
        });

        return function (_x) {
          return _ref3.apply(this, arguments);
        };
      })()));
      let componentFound = null;
      componentsList.some(function (component) {
        if (component.isComponentFile(fileName)) {
          componentFound = component;
        }
      });
      return componentFound;
    })();
  }

  runStalker() {
    var _this6 = this;

    // Stalking files
    debug('watching:', this.session.projectPath);
    this.stalker = _watchr2.default.create(this.session.projectPath);
    this.stalker.on('change', (() => {
      var _ref4 = _asyncToGenerator(function* (changeType, fileName) {
        timer.reset();
        const socketToUpdate = _this6.getSocketToUpdate(fileName);
        const componentToUpdate = yield _this6.getComponentToUpdate(fileName);
        if (componentToUpdate) {
          _this6.deployComponent(componentToUpdate);
        } else if (socketToUpdate) {
          _this6.deploySocket(socketToUpdate);
        }
      });

      return function (_x2, _x3) {
        return _ref4.apply(this, arguments);
      };
    })());

    this.stalker.setConfig({
      interval: 300,
      persistent: true,
      catchupDelay: 300,
      preferredMethods: ['watch', 'watchFile'],
      followLinks: true,
      ignoreHiddenFiles: true, // ignoring .bundles, .dist etc.
      ignoreCommonPatterns: true
    });

    // First start of the stalker
    this.stalker.watch(() => {});

    this.localSockets = _lodash2.default.filter(this.socketList, { existLocally: true });
  }

  static bail() {
    (0, _printTools.echo)();
    process.exit(1);
  }

  static printUpdateSuccessful(socketName, updateStatus, deployTimer) {
    debug('printUpdateSuccessful', socketName, updateStatus);
    const duration = _chalk2.default.dim(deployTimer.getDuration());
    const socketNameStr = `${_chalk2.default.cyan(socketName)}`;

    if (updateStatus.status === 'ok') {
      const status = _chalk2.default.grey('socket synced:');
      (0, _printTools.echo)(6)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'stopped') {
      // const status = format.grey('socket in sync:');
      // echo(5)(`${status} ${currentTime()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'error') {
      const errDetail = _chalk2.default.red(updateStatus.message.error);
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration} ${errDetail}`);
    } else {
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    }
  }

  static printUpdateFailed(socketName, err, deployTimer) {
    const duration = deployTimer.getDuration();
    const errDetail = JSON.parse(err).detail;
    (0, _printTools.echo)(3)(`${_chalk2.default.red('files not synced:')} ${(0, _dateUtils.currentTime)()} ${socketName} ${duration} ${errDetail}`);
  }
}
exports.default = SocketDeployCmd;
module.exports = exports['default'];
//# sourceMappingURL=socket-deploy-hot.js.map
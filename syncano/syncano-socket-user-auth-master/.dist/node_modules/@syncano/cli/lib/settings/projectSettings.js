'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _readdirp = require('readdirp');

var _readdirp2 = _interopRequireDefault(_readdirp);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _debug = require('../utils/debug');

var _debug2 = _interopRequireDefault(_debug);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('settings-project');

class ProjectSettings extends _settings2.default {
  constructor(projectPath) {
    super();
    this.name = 'syncano';
    this.baseDir = projectPath;
    if (projectPath) {
      this.loaded = this.load();
    }
  }

  getPlugins() {
    return this.attributes.plugins;
  }

  installSocket(socket) {
    debug('installSocket()');
    const dependencies = this.attributes.dependencies || { sockets: {} };
    const sockets = dependencies.sockets;

    sockets[socket.name] = socket.version ? { version: socket.version } : { src: `./${socket.name}` };
    this.attributes.dependencies = dependencies;

    this.save();
  }

  getAllSocketsYmlPath() {
    return new Promise((resolve, reject) => {
      const paths = [];
      (0, _readdirp2.default)({ root: this.baseDir, fileFilter: 'socket.yml' }).on('data', entry => {
        paths.push(entry.fullPath);
      }).on('end', () => {
        resolve(paths);
      }).on('error', err => {
        reject(err);
      });
    });
  }

  getHostingsList() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const socketYamls = yield _this.getAllSocketsYmlPath();
      const hostingsList = {};

      const socketsAttributes = socketYamls.map(function (yamlPath) {
        return ProjectSettings.getAttributesFromYaml(yamlPath);
      });
      socketsAttributes.forEach(function (socketAttributes) {
        hostingsList[socketAttributes.name] = socketAttributes.hosting;
      });

      return hostingsList;
    })();
  }

  static getAttributesFromYaml(path) {
    const socketAttributes = _jsYaml2.default.load(_fs2.default.readFileSync(path, 'utf8'));

    return socketAttributes;
  }

  uninstallSocket(socketName) {
    debug('uninstallSocket');
    const dependencies = this.attributes.dependencies || { sockets: {} };
    const sockets = dependencies.sockets;

    delete sockets[socketName];
    this.save();
  }

  getSocket(socketName) {
    return this.attributes.dependencies.sockets[socketName];
  }

  getSocketTemplates() {
    try {
      return this.attributes.templates.sockets;
    } catch (err) {
      return [];
    }
  }

  getDependSockets() {
    try {
      return this.attributes.dependencies.sockets;
    } catch (err) {
      return {};
    }
  }

  getDependSocket(socketName) {
    try {
      return this.attributes.dependencies.sockets[socketName];
    } catch (err) {
      return null;
    }
  }

  // Hosting
  getHosting(hostingName) {
    debug('getHosting()');
    return this.attributes.hosting ? this.attributes.hosting[hostingName] : null;
  }

  addHosting(hostingName, params) {
    if (!this.attributes.hosting) this.attributes.hosting = {};
    this.attributes.hosting[hostingName] = params;
    this.save();
  }

  deleteHosting(hostingName) {
    if (this.attributes.hosting) {
      delete this.attributes.hosting[hostingName];
    }

    if (this.listHosting().length === 0) {
      delete this.attributes.hosting;
    }
    this.save();
  }

  listHosting() {
    debug('list()');
    const hostings = this.attributes.hosting;
    const list = [];
    if (hostings) {
      for (const key of Object.keys(hostings)) {
        list.push({
          name: key,
          src: hostings[key].src
        });
      }
    }
    return list;
  }
}
exports.default = ProjectSettings;
module.exports = exports['default'];
//# sourceMappingURL=projectSettings.js.map
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HostingFile = exports.default = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _formData = require('form-data');

var _formData2 = _interopRequireDefault(_formData);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _prettyBytes = require('pretty-bytes');

var _prettyBytes2 = _interopRequireDefault(_prettyBytes);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _md = require('md5');

var _md2 = _interopRequireDefault(_md);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('./utils');

var _printTools = require('../../utils/print-tools');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('utils-hosting');

class HostingFile {
  loadRemote(fileRemoteData) {
    this.id = fileRemoteData.id;
    this.instanceName = fileRemoteData.instanceName;
    this.path = fileRemoteData.path;
    this.checksum = fileRemoteData.checksum;
    this.size = fileRemoteData.size;
    return this;
  }
  loadLocal(fileLocalData) {
    this.localPath = fileLocalData.path;
    this.path = _path2.default.basename(this.localPath);
    this.checksum = (0, _md2.default)(_fs2.default.readFileSync(this.localPath));
    this.size = _fs2.default.statSync(this.localPath).size;
    return this;
  }
}

class Hosting {
  constructor(hostingName, socket) {
    debug('Hosting.constructor', hostingName, socket);

    this.name = hostingName;
    this.socket = socket || null;
    this.path = null;

    this.existRemotely = null;
    this.existLocally = null;

    this.hostingURL = `/v2/instances/${_session2.default.project.instance}/hosting/`;
    this.editHostingURL = `https://${_session2.default.getHost()}${this.hostingURL}${this.name}/`;
    this.hostingHost = _session2.default.getHost() === 'api.syncano.rocks' ? 'syncano.ninja' : 'syncano.site';
    this.config = {};

    this.loadLocal();
  }

  static add(params) {
    return _asyncToGenerator(function* () {
      const configParams = {
        src: params.src,
        config: {
          browser_router: params.browser_router || false
        }
      };
      _session2.default.settings.project.addHosting(params.name, configParams);

      const hostingURL = `/v2/instances/${_session2.default.project.instance}/hosting/`;
      const addHostingURL = `https://${_session2.default.getHost()}${hostingURL}`;

      const domains = [params.name];
      if (params.cname) {
        domains.push(params.cname);
      }

      const paramsToAdd = {
        name: params.name,
        config: {
          browser_router: params.browser_router
        },
        domains
      };

      const response = yield _axios2.default.request({
        url: addHostingURL,
        method: 'POST',
        data: paramsToAdd,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      return response.data;
    })();
  }

  hasCNAME(cname) {
    return this.domains.indexOf(cname) > -1;
  }

  configure(params) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const domains = _this.domains;
      if (params.cname && _this.domains.indexOf(params.cname) < 0) {
        domains.push(params.cname);
      }

      if (params.removeCNAME) {
        const cnameToRemoveIndex = domains.indexOf(params.removeCNAME);
        if (cnameToRemoveIndex > -1) {
          domains.splice(cnameToRemoveIndex, 1);
        }
      }

      const paramsToUpdate = {
        name: _this.name,
        config: {
          browser_router: params.browser_router
        },
        domains
      };

      const response = yield _axios2.default.request({
        url: _this.editHostingURL,
        method: 'PATCH',
        data: paramsToUpdate,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });

      return _this.setRemoteState(response.data);
    })();
  }

  deploy() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      debug('deploy');

      if (!_this2.existRemotely) {
        debug('adding hosting');
        return Hosting.add({
          name: _this2.name,
          src: _this2.src
        });
      }

      debug('patching hosting');
      // TODO: not optimal
      const paramsToUpdate = {
        name: _this2.name,
        domains: _this2.domains
      };

      const response = yield _axios2.default.request({
        url: _this2.editHostingURL,
        method: 'PATCH',
        data: paramsToUpdate,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });

      return _this2.setRemoteState(response.data);
    })();
  }

  delete() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (!_this3.socket) {
        yield _axios2.default.request({
          url: _this3.editHostingURL,
          method: 'DELETE',
          headers: {
            'X-Api-Key': _session2.default.settings.account.getAuthKey()
          }
        });
        _session2.default.settings.project.deleteHosting(_this3.name);
        return _this3;
      }
    })();
  }

  static get(hostingName, socket) {
    debug(`get ${hostingName}`);
    const hosting = new Hosting(hostingName, socket);
    return hosting.loadRemote();
  }

  static listLocal(socket) {
    return socket.settings.listHosting();
  }

  static listFromProject() {
    return _session2.default.settings.project.listHosting();
  }

  // list all hostings (mix of locally definde and installed on server)
  static list(socket) {
    return _asyncToGenerator(function* () {
      debug('list()');
      // const localHostings = Hosting.listLocal(socket);
      if (!socket) {
        const projectHostings = Hosting.listFromProject();
        debug('projectHostings', projectHostings);
        const promises = projectHostings.map(function (hosting) {
          return Hosting.get(hosting.name);
        });
        return _bluebird2.default.all(promises);
      }
    })();
  }

  static getDirectories() {
    const excluded = ['node_modules', 'src', 'syncano'];

    function notExcluded(dirname) {
      if (dirname.startsWith('.')) {
        return;
      }
      if (excluded.indexOf(dirname) !== -1) {
        return;
      }
      return dirname;
    }

    return _fs2.default.readdirSync(process.cwd()).filter(file => {
      const dirs = [];
      if (_fs2.default.statSync(`${process.cwd()}/${file}`).isDirectory()) {
        dirs.push(file);
      }
      return dirs.find(notExcluded);
    });
  }

  setRemoteState(hosting) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      debug('setRemoteState', hosting.name);
      if (hosting && typeof hosting === 'object') {
        _this4.existRemotely = true;
        _this4.name = hosting.name;
        _this4.description = hosting.description;
        _this4.domains = hosting.domains;
        _this4.config.browser_router = hosting.config.browser_router || false;
        _this4.isUpToDate = yield _this4.areFilesUpToDate();
      } else {
        _this4.existRemotely = false;
        _this4.error = hosting;
      }
      return _bluebird2.default.resolve();
    })();
  }

  loadRemote() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      debug('loadRemote()');
      try {
        const hosting = yield _this5.getRemote();
        yield _this5.setRemoteState(hosting);
      } catch (err) {
        _this5.existRemotely = false;
      }
      return _this5;
    })();
  }

  loadLocal() {
    debug('loadLocal()');
    let localHostingSettings = {};
    if (this.socket) {
      if (this.socket.settings.loaded) {
        localHostingSettings = this.socket.settings.getHosting(this.name);
      }
    } else {
      localHostingSettings = _session2.default.settings.project.getHosting(this.name);
    }

    if (!localHostingSettings) {
      return;
    }

    if (Object.keys(localHostingSettings).length > 0) {
      this.existLocally = true;
      this.src = localHostingSettings.src;
      this.cname = localHostingSettings.cname;
      this.path = _path2.default.join(_session2.default.projectPath, this.src, _path2.default.sep);
      this.url = this.getURL(this.name);

      if (localHostingSettings.config && localHostingSettings.config.browser_router) {
        this.config.browser_router = localHostingSettings.config.browser_router;
      }
    }
  }

  getURL() {
    return `https://${this.name}--${_session2.default.project.instance}.${this.hostingHost}`;
  }

  getLocalFilePath(file) {
    debug('getLocalFilePath');
    if (!file) return null;
    return file.localPath.replace(this.path, '');
  }

  // Verify local file if it should be created or updated
  getFilesToUpload(file, remoteFiles) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      debug('getFilesToUpload');
      const localHostingFilePath = _this6.getLocalFilePath(file);
      const fileToUpdate = _lodash2.default.find(remoteFiles, { path: localHostingFilePath });
      const payload = new _formData2.default();
      payload.append('file', _fs2.default.createReadStream(file.localPath));
      payload.append('path', localHostingFilePath);

      let singleFile = null;

      if (fileToUpdate) {
        const remoteChecksum = fileToUpdate.checksum;
        const localChecksum = file.checksum;

        // Check if checksum of the local file is the same as remote one
        if (remoteChecksum === localChecksum) {
          try {
            singleFile = yield _session2.default.connection.hosting.getFile(_this6.name, fileToUpdate.id);
            (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File skipped: ${_chalk2.default.dim(localHostingFilePath)}`);
          } catch (err) {
            (0, _printTools.error)(err);
          }
        } else {
          try {
            singleFile = yield _session2.default.connection.hosting.updateFile(_this6.name, fileToUpdate.id, payload);
            (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File updated: ${_chalk2.default.dim(localHostingFilePath)}`);
          } catch (err) {
            (0, _printTools.echo)(`Error while syncing (updating) ${localHostingFilePath}`);
            debug(err.response.data);
          }
        }
      } else {
        // Adding (first upload) file
        try {
          singleFile = yield _session2.default.connection.hosting.uploadFile(_this6.name, payload);
          (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File added:   ${_chalk2.default.dim(localHostingFilePath)}`);
        } catch (err) {
          (0, _printTools.echo)(`Error while syncing (creating) ${file.path}`);
          debug(err.response.data);
        }
      }

      return singleFile;
    })();
  }

  // Files upload report
  generateUploadFilesResult(result) {
    if (!result) {
      return `\n\t${_chalk2.default.red('No files synchronized!')}\n`;
    }
    const prettyUploadSize = (0, _prettyBytes2.default)(result.uploadedSize);

    return `\n\t${_chalk2.default.cyan(result.uploadedFilesCount)} files synchronized, ${_chalk2.default.cyan(prettyUploadSize)} in total
    \t${_chalk2.default.green(this.name)} is available at: ${_chalk2.default.green(this.getURL())}\n`;
  }

  uploadFiles(files) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      let uploadedFilesCount = 0;
      let uploadedSize = 0;
      const promises = [];

      const localFiles = yield _this7.listLocalFiles();

      yield localFiles.forEach(function (file) {
        promises.push(_this7.getFilesToUpload(file, files));
      });

      const values = yield _bluebird2.default.all(promises);
      uploadedFilesCount = 0;
      uploadedSize = 0;
      values.forEach(function (upload) {
        uploadedFilesCount += 1;
        uploadedSize += upload.size;
      });
      return { uploadedFilesCount, uploadedSize };
    })();
  }

  // Run this to synchronize hosted files
  // first we are getting remote files
  syncFiles() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      debug('syncFiles()');

      if (!_fs2.default.existsSync(_this8.path)) {
        throw new Error(`Local folder ${_chalk2.default.bold(_this8.path)} doesn't exist!`);
      }

      const remoteFiles = yield _this8.listRemoteFiles();
      const result = yield _this8.uploadFiles(remoteFiles);
      return _this8.generateUploadFilesResult(result);
    })();
  }

  areFilesUpToDate() {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      debug('areFilesUpToDate()');

      // Check if local folder exist
      if (!_fs2.default.existsSync(_this9.path)) {
        return false;
      }

      const localChecksums = yield _this9.listLocalFiles().map(function (localFile) {
        return {
          filePath: _this9.getLocalFilePath(localFile),
          checksum: localFile.checksum
        };
      });

      const remoteChecksums = yield _this9.listRemoteFiles().map(function (remoteFile) {
        return {
          filePath: remoteFile.path,
          checksum: remoteFile.checksum
        };
      });

      return _lodash2.default.isEqual(_lodash2.default.sortBy(localChecksums, 'filePath'), _lodash2.default.sortBy(remoteChecksums, 'filePath'));
    })();
  }

  // Get list of the hostings first, then get the files list for given one
  listRemoteFiles() {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      debug('listRemoteFiles()');
      const files = yield _session2.default.connection.hosting.listFiles(_this10.name);
      return _bluebird2.default.all(files.map((() => {
        var _ref = _asyncToGenerator(function* (file) {
          const hostingFile = new HostingFile(file);
          return hostingFile.loadRemote(file);
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      })()));
    })();
  }

  // Get info about hostings first, then get the files list for given one
  listLocalFiles() {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      debug('listLocalFiles');
      const localHostingFiles = _this11.path ? yield (0, _utils.getFiles)(_this11.path) : [];
      if (!Array.isArray(localHostingFiles)) return localHostingFiles;

      return localHostingFiles ? localHostingFiles.map(function (file) {
        return new HostingFile().loadLocal({ path: file });
      }) : [];
    })();
  }

  listFiles() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      const remoteFiles = yield _this12.listRemoteFiles();
      const listLocalFiles = yield _this12.listLocalFiles();

      const files = [];
      listLocalFiles.forEach(function (localFile) {
        const file = localFile;
        const remoteCopy = _lodash2.default.find(remoteFiles, { path: _this12.getLocalFilePath(file) });

        if (remoteCopy) {
          file.isUpToDate = file.checksum === remoteCopy.checksum;
          file.isSynced = true;
          _lodash2.default.extend(file, remoteCopy);
        }
        files.push(file);
      });
      return files;
    })();
  }

  getCNAME() {
    return _lodash2.default.find(this.domains, domain => domain.indexOf('.') !== -1);
  }

  getCnameURL() {
    const cname = this.getCNAME();
    if (cname) {
      return `http://${cname}`;
    }
  }

  // TODO: filtering hostings (wating for core)
  static listRemote(socket) {
    return _asyncToGenerator(function* () {
      debug('listRemote');
      const hostings = yield _session2.default.connection.hosting.list();
      return hostings.map(function (hosting) {
        return new Hosting(hosting.name, socket);
      });
    })();
  }

  getRemote() {
    debug('getRemote()', this);
    return _session2.default.connection.hosting.get(this.name);
  }
}

exports.default = Hosting;
exports.HostingFile = HostingFile;
//# sourceMappingURL=hosting.js.map
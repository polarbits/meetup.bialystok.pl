'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _klawSync = require('klaw-sync');

var _klawSync2 = _interopRequireDefault(_klawSync);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _findKey = require('find-key');

var _findKey2 = _interopRequireDefault(_findKey);

var _md = require('md5');

var _md2 = _interopRequireDefault(_md);

var _hashdirectory = require('hashdirectory');

var _hashdirectory2 = _interopRequireDefault(_hashdirectory);

var _unzip = require('unzip2');

var _unzip2 = _interopRequireDefault(_unzip);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _readdirp = require('readdirp');

var _readdirp2 = _interopRequireDefault(_readdirp);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _formData = require('form-data');

var _formData2 = _interopRequireDefault(_formData);

var _archiver = require('archiver');

var _archiver2 = _interopRequireDefault(_archiver);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _es6TemplateStrings = require('es6-template-strings');

var _es6TemplateStrings2 = _interopRequireDefault(_es6TemplateStrings);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _ws = require('ws');

var _ws2 = _interopRequireDefault(_ws);

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _hosting = require('../hosting');

var _hosting2 = _interopRequireDefault(_hosting);

var _registry = require('../registry');

var _registry2 = _interopRequireDefault(_registry);

var _printTools = require('../print-tools');

var _templates = require('../templates');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('utils-sockets');

class MetadataObject {
  constructor(name, metadata, socketName) {
    this.name = name;
    this.metadata = metadata;
    this.socketName = socketName;
    this.existRemotely = null;
    this.existLocally = null;
    this.isProjectRegistryDependency = null;
  }
  getStatus() {
    if (this.existLocally && this.existRemotely) {
      return { status: 'synced', type: 'ok' };
    }

    if (this.existLocally && !this.existRemotely) {
      return { status: 'not synced', type: 'warn' };
    }

    if (!this.existLocally && this.existRemotely) {
      return { status: 'no local configuration', type: 'fail' };
    }
  }
}

class Endpoint extends MetadataObject {
  call(params) {
    return _axios2.default.request({
      url: this.getURL(),
      method: 'POST',
      timeout: 3000,
      params,
      // Do not transform data automaticaly
      transformResponse: data => data
    });
  }

  getFullName() {
    return `${this.socketName}/${this.name}`;
  }

  getURL() {
    return `https://${_session2.default.getSpaceHost()}/${this.socketName}/${this.name}/`;
  }
}

class Handler extends MetadataObject {}

class Event extends MetadataObject {}

class Component extends MetadataObject {
  constructor(name, metadata, socketName) {
    super(name, metadata, socketName);
    this.componentPath = _path2.default.join(Socket.getLocal(this.socketName).socketPath, this.metadata.path);
    this.packageName = this.getRealName();
  }
  getRealName() {
    debug('getRealComponentName');
    return JSON.parse(_fs2.default.readFileSync(_path2.default.join(this.componentPath, 'package.json'))).name;
  }

  linkWithProject(projectPath) {
    debug('linkWithProject');
    _child_process2.default.spawnSync('yarn', ['link'], {
      cwd: this.componentPath,
      maxBuffer: 2048 * 1024,
      stdio: [process.stdio, 'pipe', 'pipe']
    });
    _child_process2.default.spawnSync('yarn', ['link', this.packageName], {
      cwd: projectPath,
      maxBuffer: 2048 * 1024,
      stdio: [process.stdio, 'pipe', 'pipe']
    });
  }

  isComponentFile(filePath) {
    return filePath.includes(_path2.default.join(this.componentPath, 'src'));
  }

  build() {
    var _this = this;

    debug(`component build: ${this.packageName}`);

    return new _bluebird2.default((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        const command = 'npm';
        const args = 'run build -s';

        process.env.FORCE_COLOR = true;
        const out = _child_process2.default.spawnSync(command, args.split(' '), {
          cwd: _this.componentPath,
          maxBuffer: 2048 * 1024,
          stdio: [process.stdio, 'pipe', 'pipe']
        });

        if (out.status !== 0) {
          reject(new _errors.CompileError(out.stderr.toString()));
        } else {
          resolve();
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }
}

class Socket {
  constructor(socketName, socketPath) {
    debug('Sockets.constructor', socketName);
    this.name = socketName;
    this.settings = { loaded: false };
    this.socketPath = socketPath || _utils2.default.findLocalPath(socketName);

    if (this.socketPath) {
      this.settings = _session2.default.settings.getSocketSettings(this.socketPath, this.name);
    }

    this.existRemotely = null;
    this.existLocally = null;
    this.isProjectRegistryDependency = null;
    this.dependencies = [];
    this.dependencyOf = [];

    // that looks stupid
    this.remote = {
      spec: {
        endpoints: {},
        event_handlers: {},
        events: {},
        components: {}
      },
      metadata: {}
    };

    this.spec = {
      spec: {
        endpoints: {},
        event_handlers: {},
        events: {},
        components: {}
      }
    };

    this.loadLocal();

    // SocketPath for non-local sockets
    if (this.isDependencySocket || this.isProjectRegistryDependency) {
      this.socketPath = _path2.default.join(_session2.default.getBuildPath(), this.name);
    }
  }

  static getTemplatesChoices() {
    return _utils2.default.getTemplatesChoices();
  }

  // Install / Uninstall
  static add(registrySocket) {
    debug('add()');
    _session2.default.settings.project.installSocket(registrySocket);
  }

  // Install / Uninstall
  static install(registrySocket, config) {
    return _asyncToGenerator(function* () {
      debug('install()');

      const socketName = registrySocket.name;
      _session2.default.settings.project.installSocket(registrySocket);

      const socketFolder = _path2.default.join(_session2.default.getBuildPath(), socketName);
      _mkdirp2.default.sync(socketFolder);

      debug('Getting socket from registry');
      yield _registry2.default.getSocket(registrySocket, config);

      debug('Registry socket:', registrySocket);
      const fileName = _path2.default.join(_session2.default.getBuildPath(), `${socketName}.zip`);

      return new _bluebird2.default(function (resolve, reject) {
        _fs2.default.createReadStream(fileName).pipe(_unzip2.default.Extract({ path: socketFolder })).on('close', _asyncToGenerator(function* () {
          debug('Unzip finished');
          try {
            const newSocket = new Socket(socketName, socketFolder);
            yield Socket.updateSocketNPMDeps(socketFolder);
            yield newSocket.loadRemote();

            const updateStatus = yield newSocket.update({ config });
            debug('updateStatus', updateStatus);
            newSocket.updateStatus = updateStatus;
            resolve(newSocket);
          } catch (err) {
            reject(err);
          }
        }));
      });
    })();
  }

  static uninstall(socket = {}) {
    debug('uninstall', socket.name);

    if (socket.isProjectRegistryDependency) {
      _session2.default.settings.project.uninstallSocket(socket.name);
    }

    if (socket.existLocally && socket.localPath) {
      Socket.uninstallLocal(socket);
      if (socket.existRemotely) {
        this.uninstallRemote(socket.name);
      }
      return _bluebird2.default.resolve();
    }

    if (socket.existRemotely) {
      return this.uninstallRemote(socket.name);
    }

    return _bluebird2.default.reject(new Error('Socket with given doesn\'t exist!'));
  }

  static uninstallLocal(socket) {
    _utils2.default.deleteFolderRecursive(socket.localPath);
  }

  // TODO: check if the socket is installed (it may be not yet installed yet (before sync))
  static uninstallRemote(socketName) {
    return _asyncToGenerator(function* () {
      debug('uninstallRemote', socketName);
      return _session2.default.connection.socket.delete(socketName);
    })();
  }

  // list sockets based on call to Syncano (sockets are installed on Synano)
  static listRemote() {
    debug('listRemote()');
    return _session2.default.connection.socket.list();
  }

  static listDeps() {
    // List project dependencies
    return Object.keys(_session2.default.settings.project.getDependSockets());
  }

  // list all sockets (mix of locally definde and installed on server)
  static list() {
    return _asyncToGenerator(function* () {
      debug('list()');
      // Local Socket defined in folders and in project deps
      const localSocketsList = _utils2.default.listLocal().concat(Socket.listDeps());
      return _bluebird2.default.all(localSocketsList.map(function (socketName) {
        return Socket.get(socketName);
      }));
    })();
  }

  static flatList(socketName) {
    return _asyncToGenerator(function* () {
      debug('flatList()');
      const sockets = [];

      const addToList = function (socket) {
        const duplicated = _lodash2.default.find(sockets, function (s) {
          return s.name === socket.name;
        });
        if (duplicated) {
          if (!_lodash2.default.includes(duplicated.dependencyOf, socket.name)) {
            duplicated.dependencyOf.concat(socket.dependencyOf);
          }
        } else {
          sockets.push(socket);
          socket.dependencies.forEach(function (dep) {
            addToList(dep);
          });
        }
      };

      if (socketName) {
        const socket = yield Socket.get(socketName);
        addToList(socket);
        return sockets;
      }

      // All Sockets
      const allSockets = yield Socket.list();
      allSockets.forEach(function (socket) {
        addToList(socket);
      });
      return sockets;
    })();
  }

  // Creating Socket simple object
  static getLocal(socketName) {
    debug('getLocal');
    return new Socket(socketName);
  }

  static get(socketName) {
    return _asyncToGenerator(function* () {
      debug(`Getting Socket: ${socketName}`);
      const socket = Socket.getLocal(socketName);
      const loadedSocket = yield socket.loadRemote();
      yield loadedSocket.getDepsRegistrySockets();

      if (!socket.existLocally) {
        yield socket.loadFromRegistry();
      }
      return socket;
    })();
  }

  static create(socketName, templateName) {
    debug('create socket', socketName, templateName);
    const newSocketPath = _path2.default.join(_session2.default.projectPath, socketName);
    const socket = new Socket(socketName, newSocketPath);
    if (socket.existLocally) {
      return _bluebird2.default.reject(new Error('Socket with given name already exist!'));
    }
    return socket.init(templateName);
  }

  static publish(socketName, version) {
    debug('publish');
    const registry = new _registry2.default();
    return registry.publishSocket(socketName, version);
  }

  init(templateName) {
    debug('init', templateName);
    return new _bluebird2.default((resolve, reject) => {
      const socketPath = this.getSocketPath();
      if (!_fs2.default.existsSync(socketPath)) {
        _mkdirp2.default.sync(socketPath);
      }

      try {
        const templateFolder = _path2.default.normalize((0, _templates.getTemplate)(templateName));
        const files = (0, _klawSync2.default)(templateFolder, { nodir: true });
        files.forEach(file => {
          const oldContent = _fs2.default.readFileSync(file.path, 'utf8');
          const socket = {
            socketName: this.name,
            socketDescription: `Description of ${this.name}`
          };

          const newContent = (0, _es6TemplateStrings2.default)(oldContent, socket, { partial: true });
          const fileToSave = _path2.default.join(socketPath, file.path.replace(templateFolder, ''));

          _mkdirp2.default.sync(_path2.default.parse(fileToSave).dir);
          _fs2.default.writeFileSync(_path2.default.join(socketPath, file.path.replace(templateFolder, '')), newContent);
        });
        resolve(this);
      } catch (err) {
        return reject(err);
      }
    });
  }

  verify() {
    return new _bluebird2.default((resolve, reject) => {
      if (!(this.isDependencySocket || this.isProjectRegistryDependency)) {
        if (!_fs2.default.existsSync(this.getSrcFolder())) {
          reject(new Error('No src folder!'));
        }
      }
      resolve();
    });
  }

  getFullConfig() {
    return this.settings.getFull();
  }

  getRemote() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      debug('getRemote', _this2.name);
      try {
        return yield _session2.default.connection.socket.get(_this2.name);
      } catch (err) {
        return false;
      }
    })();
  }

  getRemoteSpec() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      debug('getRemoteSpec');
      if (_this3.remote.files['socket.yml']) {
        try {
          const spec = yield _axios2.default.request({
            url: _this3.remote.files['socket.yml'].file,
            method: 'GET',
            timeout: 3000
          });
          _this3.remote.spec = _jsYaml2.default.load(spec.data);
        } catch (err) {}
      }
    })();
  }

  setRemoteState(socket) {
    this.existRemotely = true;
    this.remote.name = socket.name;
    this.remote.environment = socket.environment;
    this.remote.version = socket.version;
    this.remote.updatedAt = socket.updated_at;
    this.remote.installed = socket.installed;
    this.remote.files = socket.files;
    this.remote.status = socket.status;
    this.remote.statusInfo = socket.status_info;
    this.remote.config = socket.config;
    this.remote.metadata = socket.metadata;
  }

  loadRemote() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      debug('loadRemote()');
      const socket = yield _this4.getRemote();
      if (socket) {
        yield _this4.setRemoteState(socket);
        yield _this4.getRemoteSpec();
      } else {
        _this4.existRemotely = false;
      }
      return _this4;
    })();
  }

  loadFromRegistry() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      debug(`loadFromRegistry: ${_this5.name}`);
      const registry = new _registry2.default();
      const registrySocket = yield registry.searchSocketByName(_this5.name);

      if (registrySocket.config) {
        _this5.spec = registrySocket.config;
      }
      _this5.url = registrySocket.url;
    })();
  }

  loadLocal() {
    debug('loadLocal()');
    if (this.settings.loaded) {
      this.existLocally = true;
      this.localPath = this.settings.baseDir;
      this.spec = this.settings.getFull();
    } else if (_lodash2.default.includes(Socket.listDeps(), this.name)) {
      this.isProjectRegistryDependency = true;
      this.existLocally = false;
      this.spec.version = _session2.default.settings.project.getDependSocket(this.name).version;
    }
  }

  isSocketFile(fileFullPath) {
    debug('isSocketFile', fileFullPath);
    return fileFullPath.includes(this.localPath);
  }

  getRawStatus() {
    return {
      isProjectRegistryDependency: this.isProjectRegistryDependency,
      existRemotely: this.existRemotely,
      existLocally: this.existLocally
    };
  }

  getStatus() {
    if (this.isProjectRegistryDependency && !this.existRemotely) {
      return { status: 'not synced', type: 'warn' };
    }

    if (this.existLocally && !this.existRemotely) {
      return { status: 'not synced', type: 'warn' };
    }

    let msg = this.remote.statusInfo || this.remote.status;
    if (msg && msg.error) {
      msg = msg.error;
    }

    if (this.remote.status === 'ok') {
      return { status: msg, type: 'ok' };
    } else if (this.remote.status === 'processing') {
      return { status: msg, type: 'warn' };
    }
    return { status: msg, type: 'fail' };
  }

  getType() {
    if (this.isProjectRegistryDependency) {
      return { msg: 'project dependency', type: 'ok' };
    }

    if (this.isDependencySocket) {
      return { msg: `dependency of ${this.dependencyOf.join(', ')}`, type: 'ok' };
    }

    if (this.existLocally) {
      return { msg: 'local Socket', type: 'ok' };
    }

    return { msg: 'no local configuration', type: 'warn' };
  }

  getVersion() {
    return this.remote ? this.remote.version : null;
  }

  getScripts() {
    return (0, _findKey2.default)(this.spec, 'file');
  }

  getSrcFolder() {
    return _path2.default.join(this.getSocketPath(), 'src', _path2.default.sep);
  }

  getCompiledScriptsFolder() {
    const folder = _path2.default.join(this.getSocketPath(), '.dist', 'src', _path2.default.sep);
    if (!_fs2.default.existsSync(folder)) {
      _mkdirp2.default.sync(folder);
    }
    return folder;
  }

  getSocketZip() {
    debug('getSocketZip');
    return _path2.default.join(_session2.default.getDistPath(), `${this.name}.zip`);
  }

  getSocketEnvZip() {
    debug('getSocketEnvZip');
    return _path2.default.join(_session2.default.getDistPath(), `${this.name}.env.zip`);
  }

  getSocketNodeModulesChecksum() {
    debug('getSocketNodeModulesChecksum');
    return _hashdirectory2.default.sync(_path2.default.join(this.socketPath, '.dist', 'node_modules'));
  }

  getSocketConfigFile() {
    return _path2.default.join(_session2.default.projectPath, this.name, 'socket.yml');
  }

  composeFromSpec(objectType, ObjectClass) {
    debug('composeFromSpec', objectType, ObjectClass);
    const objects = Object.assign({}, this.remote.spec[objectType]);
    Object.assign(objects, this.spec[objectType]);

    debug('objects to process', objects);
    return Object.keys(objects).map(objectName => {
      debug(`checking ${objectName}`);
      const objectMetadata = objects[objectName];
      debug('objectMetadata', objectMetadata);
      const object = new ObjectClass(objectName, objectMetadata, this.name);

      debug('existRemotely', this.remote.spec[objectType], objectName);
      if (this.remote.spec[objectType][objectName]) {
        debug(`existRemotely: ${true}`);
        object.existRemotely = true;
      }

      if (this.spec[objectType] && this.spec[objectType][objectName]) {
        object.existLocally = true;
      }
      return object;
    });
  }

  composeComponentsFromSpec(objectType, ObjectClass) {
    debug('composeComponentsFromSpec', objectType, ObjectClass);
    const objects = Object.assign({}, this.spec[objectType]);
    Object.assign(objects, this.spec[objectType]);

    debug('objects to process', objects);
    return Object.keys(objects).map(objectName => {
      debug(`checking ${objectName}`);
      const objectMetadata = objects[objectName];
      debug('objectMetadata', objectMetadata);
      const object = new ObjectClass(objectName, objectMetadata, this.name);
      return object;
    });
  }

  getEndpoints() {
    debug('getEndpoints');
    return this.composeFromSpec('endpoints', Endpoint);
  }

  getEndpoint(endpointName) {
    debug('getEndpoints');
    return _lodash2.default.find(this.getEndpoints(), { name: endpointName });
  }

  getEventHandlers() {
    debug('getEventHandlers');
    return this.composeFromSpec('event_handlers', Handler);
  }

  getEvents() {
    debug('getEvents');
    return this.composeFromSpec('events', Event);
  }

  getEndpointTrace(endpointName, traceId) {
    return _session2.default.connection.trace.get(this.name, endpointName, traceId);
  }

  getEndpointTraces(endpointName, lastId) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      debug('getEndpointTraces', endpointName, lastId);
      try {
        const traces = yield _session2.default.connection.trace.get(_this6.name, endpointName);
        if (!lastId) {
          return traces;
        }
        const filteredTraces = [];
        traces.forEach(function (trace) {
          if (trace.id > lastId) {
            filteredTraces.push(trace);
          }
        });
        return filteredTraces;
      } catch (err) {}
    })();
  }

  getTraces(lastId) {
    const url = [`https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/channels/eventlog/poll/`, '?transport=websocket', `&api_key=${_session2.default.settings.account.getAuthKey()}`, `&room=${`socket:${this.name}`}`].join('');

    return new _ws2.default(url);
  }

  static getEndpointTraceByUrl(url) {
    return _asyncToGenerator(function* () {
      const resp = yield _axios2.default.request({
        url: `https://${_session2.default.getHost()}${url}`,
        method: 'GET',
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      return resp.data;
    })();
  }

  getComponents() {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      debug('getComponents');
      debug('getEndpoints');
      return _this7.composeComponentsFromSpec('components', Component);
    })();
  }

  createZip({ plainSources = false } = {}) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      debug('createZip');
      return new _bluebird2.default(function (resolve, reject) {
        let numberOfFiles = 0;
        const allFilesList = [];

        const archive = (0, _archiver2.default)('zip', { zlib: { level: 9 } });
        const output = _fs2.default.createWriteStream(_this8.getSocketZip(), { mode: 0o700 });

        archive.pipe(output);
        archive.on('error', reject);

        function fileFilter(file) {
          const remoteFiles = this.remote.files;
          if (file.fullPath.match(/yarn\.lock/)) {
            return false;
          }
          if (file.fullPath.match(/.*\.log$/)) {
            return false;
          }
          if (file.fullPath.match(/node_modules/)) {
            return false;
          }
          if (file.fullPath.match(/\.js\.map$/)) {
            return false;
          }
          if (!plainSources && file.fullPath.match(/\.js$/)) {
            return false;
          }
          if (file.fullPath.match(/\.js$/)) {
            return false;
          }
          if (file.path.match(/^\./)) {
            return false;
          }
          debug(`createZip: Checking file ${file.name}`);
          if (remoteFiles) {
            const remoteFile = remoteFiles[file.path];
            if (remoteFile) {
              return remoteFile.checksum !== (0, _md2.default)(_fs2.default.readFileSync(file.fullPath));
            }
            return true;
          }
          return true;
        }

        const findFiles = (0, _readdirp2.default)({ root: _this8.getSrcFolder(), fileFilter: fileFilter.bind(_this8) });

        // Adding socket.yml if needed
        const localYMLChecksum = (0, _md2.default)(_fs2.default.readFileSync(_this8.getSocketYMLFile()));
        const remoteYMLChecksum = _this8.remote.files && _this8.remote.files['socket.yml'] ? _this8.remote.files['socket.yml'].checksum : '';
        if (remoteYMLChecksum !== localYMLChecksum) {
          debug('Adding file to archive: \'socket.yml\'');
          archive.file(_this8.getSocketYMLFile(), { name: 'socket.yml' });
          allFilesList.push('socket.yml');
          numberOfFiles += 1;
        } else {
          debug('Ignoring file: socket.yml');
        }

        // Adding all files (besides those filtered out)
        findFiles.on('data', function (file) {
          // with "internal" path
          const fileNameWithPath = file.fullPath.replace(`${_this8.getSrcFolder()}`, '');
          debug(`Adding file to archive: ${fileNameWithPath}`);
          archive.file(file.fullPath, { name: fileNameWithPath });
          allFilesList.push(fileNameWithPath);
          numberOfFiles += 1;
        });

        findFiles.on('end', _asyncToGenerator(function* () {
          if (!plainSources) {
            const scripts = yield _this8.getScriptsInSocket();
            scripts.forEach(function (script) {
              const scriptNameWithPath = script.srcFile.replace(`${_this8.getSrcFolder()}`, '');
              const scriptBundlePath = script.compiledFile;
              const remoteFile = _this8.remote.files ? _this8.remote.files[scriptNameWithPath] : null;

              allFilesList.push(scriptNameWithPath);

              if (remoteFile) {
                if (!_fs2.default.existsSync(scriptBundlePath)) {
                  return;
                }
                const scriptLocalChecksum = (0, _md2.default)(_fs2.default.readFileSync(scriptBundlePath));
                const scriptRemoteChecksum = remoteFile.checksum;
                if (scriptLocalChecksum === scriptRemoteChecksum) {
                  debug('Ignoring file:', scriptNameWithPath);
                  return;
                }
              }

              debug(`Adding file to archive: ${scriptNameWithPath}`);
              archive.file(scriptBundlePath, { name: scriptNameWithPath });
              numberOfFiles += 1;
            });
            debug(`createZip: all files processed: ${numberOfFiles}`);
          }
          archive.finalize();
        }));

        output.on('close', function () {
          resolve({ numberOfFiles, allFilesList });
        });
      });
    })();
  }

  createPackageZip() {
    debug('createPackageZip');
    return new _bluebird2.default((resolve, reject) => {
      const archive = (0, _archiver2.default)('zip', { zlib: { level: 9 } });
      const output = _fs2.default.createWriteStream(this.getSocketZip(), { mode: 0o700 });

      archive.pipe(output);
      archive.on('error', reject);

      archive.file(this.getSocketYMLFile(), { name: 'socket.yml' });
      archive.file(_path2.default.join(this.getSocketPath(), 'package.json'), { name: 'package.json' });
      archive.directory(this.getSrcFolder(), 'src');
      archive.directory(_path2.default.join(this.getSocketPath(), 'bin'), 'bin');
      archive.finalize();

      output.on('close', () => {
        debug('package zip created:', this.getSocketZip());
        resolve();
      });
    });
  }

  createEnvZip() {
    debug('createEnvZip');
    return new _bluebird2.default((resolve, reject) => {
      const output = _fs2.default.createWriteStream(this.getSocketEnvZip(), { mode: 0o700 });
      const archive = (0, _archiver2.default)('zip', { zlib: { level: 9 } });

      const envFolder = _path2.default.join(this.getSocketPath(), '.dist', 'node_modules');

      if (!_fs2.default.existsSync(envFolder)) {
        _mkdirp2.default.sync(envFolder);
      }

      archive.pipe(output);
      archive.on('error', reject);

      archive.directory(envFolder, 'node_modules');

      archive.finalize();
      output.on('close', () => {
        resolve();
      });
    });
  }

  updateEnvCall(method) {
    return new _bluebird2.default((resolve, reject) => {
      const form = new _formData2.default();

      let endpointPath = `/v2/instances/${_session2.default.project.instance}/environments/`;
      if (method === 'PATCH') {
        endpointPath = `/v2/instances/${_session2.default.project.instance}/environments/${this.name}/`;
      }

      debug('endpointPath', endpointPath);
      form.append('name', this.name);
      form.append('metadata', JSON.stringify({ checksum: this.getSocketNodeModulesChecksum() }));
      form.append('zip_file', _fs2.default.createReadStream(this.getSocketEnvZip()));
      debug('upload env zip');
      form.submit({
        method,
        protocol: 'https:',
        host: _session2.default.getHost(),
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        },
        path: endpointPath

      }, (err, res) => {
        debug('end env upload');
        if (res.statusCode === 200) {
          resolve();
        }

        if (res.statusCode === 413) {
          debug('error while updating environment - environment is to big :(');
          return reject(new Error('environment is to big'));
        }

        if (err || res.statusCode === 404) {
          debug(`environment ${this.name} was not found`);
          return reject(err || res);
        }

        res.on('data', data => {
          const message = data.toString();

          if (res.statusCode > 299) {
            debug(`error while updating environment (${res.statusCode})`);
            return reject(message);
          }

          debug(`environment ${this.name} was found`);
          resolve(message);
        });
      });
    });
  }

  updateEnv() {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      debug('updateEnv');
      const resp = yield _this9.socketEnvShouldBeUpdated();
      if (resp) {
        yield _this9.createEnvZip();
        return _this9.updateEnvCall(resp);
      }
      return 'No need to update';
    })();
  }

  postSocketZip(config) {
    debug('postSocketZip');
    return this.zipCallback({ config, install: true });
  }

  patchSocketZip(config) {
    debug('patchSocketZip');
    return this.zipCallback({ config, install: false });
  }

  zipCallback({ config, install = false }) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      debug('zipCallback');
      let endpointPath = `/v2/instances/${_session2.default.project.instance}/sockets/`;

      if (!install) {
        endpointPath += `${_this10.name}/`;
      }

      const { numberOfFiles, allFilesList } = yield _this10.createZip();
      if (numberOfFiles === 0 && _this10.isConfigSynced) {
        debug('config is synced and nothing to update');
        return _bluebird2.default.resolve();
      }
      debug('preparing update');

      return new _bluebird2.default(function (resolve, reject) {
        const form = new _formData2.default();

        form.append('name', _this10.name);
        form.append('environment', _this10.name);

        if (config) {
          form.append('config', JSON.stringify(config));
        }

        const metadata = Object.assign({}, _this10.remote.metadata, { sources: _this10.getSocketSrcChecksum() });
        form.append('metadata', JSON.stringify(metadata));

        form.append('zip_file_list', JSON.stringify(allFilesList));
        if (numberOfFiles > 0) {
          form.append('zip_file', _fs2.default.createReadStream(_this10.getSocketZip()));
        }

        form.submit({
          method: install ? 'POST' : 'PATCH',
          protocol: 'https:',
          host: _session2.default.getHost(),
          headers: {
            'X-Api-Key': _session2.default.settings.account.getAuthKey()
          },
          path: endpointPath

        }, function (err, res) {
          debug('end upload');
          let responseData = '';
          let responseCode = '';
          res.on('data', function (data) {
            responseData += data.toString();
            responseCode = res.statusCode;
          });
          res.on('end', function () {
            if (err || responseCode === 404) {
              debug(`socket ${_this10.name} was not found`);
              return reject(err || res);
            }

            if (responseCode > 299) {
              debug(`error while updating socket (${res.statusCode})`);
              return reject(responseData);
            }

            debug(`socket ${_this10.name} was found`);
            resolve(responseData);
          });
        });
      });
    })();
  }

  getSocketPath() {
    if (this.isDependencySocket || this.isProjectRegistryDependency) {
      const socketFolder = _path2.default.join(_session2.default.getBuildPath(), this.name);
      _mkdirp2.default.sync(socketFolder);
      return socketFolder;
    }
    return this.socketPath;
  }

  getSocketYMLFile() {
    return _path2.default.join(this.getSocketPath(), 'socket.yml');
  }

  // async preCompileRegistrySocket () {
  //   await Registry.getSocket(this)
  //   const fileName = path.join(session.getBuildPath(), `${this.name}.zip`)
  //
  //   return new Promise((resolve, reject) => {
  //     fs.createReadStream(fileName)
  //       .pipe(unzip.Extract({ path: this.getSocketPath() }))
  //       .on('close', () => {
  //         debug('Unzip finished')
  //         resolve(this.compile())
  //       })
  //   })
  // }

  compile(params = { updateSocketNPMDeps: false }) {
    var _this11 = this;

    debug(`compile: ${this.name}`);
    debug(`compile socketPath: ${this.getSocketPath()}`);

    return new _bluebird2.default((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        if (_this11.isDependencySocket || _this11.isProjectRegistryDependency) {
          yield _registry2.default.getSocket(_this11);
          const fileName = _path2.default.join(_session2.default.getBuildPath(), `${_this11.name}.zip`);

          yield new _bluebird2.default(function (resolve, reject) {
            _fs2.default.createReadStream(fileName).pipe(_unzip2.default.Extract({ path: _this11.getSocketPath() })).on('close', function () {
              debug('Unzip finished');
              resolve();
            });
          });
        }

        const command = 'npm';
        let args = null;

        if (params.updateSocketNPMDeps) {
          args = 'run build -s';
        } else {
          args = 'run build:src -s';
        }

        process.env.FORCE_COLOR = true;
        const out = _child_process2.default.spawnSync(command, args.split(' '), {
          cwd: _this11.getSocketPath(),
          maxBuffer: 2048 * 1024,
          stdio: [process.stdio, 'pipe', 'pipe']
        });

        if (out.status !== 0) {
          reject(new _errors.CompileError(out.stderr.toString()));
        } else {
          resolve();
        }
      });

      return function (_x3, _x4) {
        return _ref4.apply(this, arguments);
      };
    })());
    // let compilation = null
    // if (params.updateSocketNPMDeps) {
    //   if (this.isDependencySocket || this.isProjectRegistryDependency) {
    //     compilation = this.preCompileRegistrySocket()
    //   } else {
    //     compilation = utils.updateSocketNPMDeps(this.getSocketPath())
    //   }
    // } else {
    //   compilation = Promise.resolve()
    // }
    //
    // return compilation
    //   .then((updateSocketDepsStatus) => {
    //     debug('updateSocketDepsStatus', updateSocketDepsStatus)
    //     return compile([this], params.withSourceMaps)
    //   })
  }

  isConfigSynced(config) {
    debug('isConfigSynced');
    return _lodash2.default.isEqual(config, this.remote.config);
  }

  updateConfig(config) {
    if (this.isConfigSynced(config)) {
      return _bluebird2.default.resolve();
    }
    return _axios2.default.request({
      url: `https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/sockets/${this.name}/`,
      method: 'PATCH',
      data: { config },
      headers: {
        'X-Api-Key': _session2.default.settings.account.getAuthKey()
      }
    });
  }

  update(params = { config: null, updateSocketNPMDeps: false, updateEnv: false }) {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      debug(`Socket update: ${_this12.name}`, params);
      const config = Object.assign({}, _this12.remote.config, params.config);

      // Get options from the env
      if (_this12.spec.config) {
        Object.keys(_this12.spec.config).forEach(function (optionName) {
          const envValue = _this12.getConfigOptionFromEnv(optionName);
          if (envValue) {
            debug(`setting value from env for: ${optionName}`);
            config[optionName] = envValue;
          }
        });
      }

      yield _this12.verify();
      yield _this12.compile({ updateSocketNPMDeps: params.updateSocketNPMDeps });
      if (params.updateEnv) {
        yield _this12.updateEnv();
      }

      let resp = null;
      if (_this12.existRemotely) {
        resp = yield _this12.patchSocketZip(config);
      } else {
        resp = yield _this12.postSocketZip(config);
      }

      if (resp && resp.status !== 'ok') return _this12.waitForStatusInfo();
      return { status: 'stopped' };
    })();
  }

  waitForStatusInfo() {
    var _this13 = this;

    debug('waitForStatusInfo');

    return new _bluebird2.default((resolve, reject) => {
      const getStatus = (() => {
        var _ref5 = _asyncToGenerator(function* () {
          const socket = yield _this13.getRemote();
          if (socket.status !== 'ok' && socket.status !== 'error') {
            setTimeout(getStatus, 200);
          } else {
            _this13.setRemoteState(socket);
            resolve({ status: socket.status, message: socket.status_info });
          }
        });

        return function getStatus() {
          return _ref5.apply(this, arguments);
        };
      })();
      getStatus();
    });
  }

  // Hosting
  addHosting(hostingName, params) {
    this.settings.addHosting(hostingName, params);
    this.settings.save();
  }

  getHosting(hostingName) {
    return _hosting2.default.get(this, hostingName);
  }

  listHostings() {
    return _hosting2.default.list(this);
  }

  deleteHosting(hostingName) {
    this.settings.deleteHosting(hostingName);
    this.settings.save();
    (0, _printTools.echo)();
    (0, _printTools.echo)(4)(`Hosting ${hostingName} of ${this.name} has been deleted from config...`);
  }

  getScriptObject(fileFullPath) {
    const srcFile = fileFullPath;
    const compiledFile = fileFullPath.replace(this.getSrcFolder(), this.getCompiledScriptsFolder());
    return {
      srcFile,
      compiledFile
    };
  }

  getScriptsInSocket() {
    debug('getScriptsInSocket');

    return new _bluebird2.default((resolve, reject) => {
      function fileFilter(file) {
        const fileWithLocalPath = file.fullPath.replace(`${this.getSocketPath()}${_path2.default.sep}`, '');
        if (fileWithLocalPath.match(/test/)) {
          return false;
        }
        if (fileWithLocalPath.match(/tests/)) {
          return false;
        }
        if (fileWithLocalPath.match(/\.bundles/)) {
          return false;
        }
        if (fileWithLocalPath.match(/node_modules/)) {
          return false;
        }
        if (!fileWithLocalPath.match(/\.js$/)) {
          return false;
        }
        return true;
      }

      const findFiles = (0, _readdirp2.default)({ root: this.getSrcFolder(), fileFilter: fileFilter.bind(this) });
      const files = [];
      // Adding all files (besides those filtered out)
      findFiles.on('data', file => {
        files.push(this.getScriptObject(file.fullPath));
      });

      findFiles.on('end', () => {
        resolve(files);
      });
    });
  }

  getScriptsToCompile() {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      debug('getScriptsToCompile');

      const files = yield _this14.getScriptsInSocket();
      const filesToCompile = [];
      files.forEach(function (file) {
        const fileNameWithLocalPath = file.srcFile.replace(_this14.getSrcFolder(), '');
        const localSrcChecksum = (0, _md2.default)(_fs2.default.readFileSync(file.srcFile, 'utf8'));
        const remoteSrcChecksum = _this14.remote.metadata.sources ? _this14.remote.metadata.sources[fileNameWithLocalPath] : '';

        debug(`Checksums for ${fileNameWithLocalPath}`, localSrcChecksum, remoteSrcChecksum);
        if (localSrcChecksum !== remoteSrcChecksum) {
          filesToCompile.push(file);
        }
      });
      return filesToCompile;
    })();
  }

  getFileForEndpoint(endpointName) {
    if (endpointName.startsWith('events')) {
      return this.spec.event_handlers[endpointName].file;
    }
    return this.spec.endpoints[endpointName].file;
  }

  getSourceMapPath(endpointName) {
    const filePath = this.getFileForEndpoint(endpointName);
    const { base, dir } = _path2.default.parse(filePath);
    return _path2.default.join(this.getSocketPath(), dir, '.bundles', `${base}.map`);
  }

  getOrigFileLine(traceData, endpointName) {
    const smc = new _sourceMap2.default.SourceMapConsumer(_fs2.default.readFileSync(this.getSourceMapPath(endpointName), { encoding: 'utf-8' }));
    return smc.originalPositionFor({
      line: traceData.lineNumber,
      column: traceData.columnNumber
    });
  }

  getPrettyTrace(traceData, endpointName) {
    const origFileLine = this.getOrigFileLine(traceData, endpointName);
    const origFilePath = _utils2.default.getOrigFilePath(origFileLine);

    return {
      origFilePath,
      lineNumber: origFileLine.line,
      columnNumber: origFileLine.column,
      lines: [_fs2.default.readFileSync(
      // origFilePath,
      _path2.default.join(this.getSocketPath(), '../', origFilePath), { encoding: 'utf-8' }).split('\n')[origFileLine.line - 1], (0, _printTools.p)(origFileLine.column)('^')]
    };
  }

  // Config
  getConfigOptions() {
    return this.spec.config;
  }

  getConfigOptionFromEnv(optionName) {
    return process.env[`${this.name.toUpperCase()}_${optionName.toUpperCase()}`];
  }

  getConfigOptionsToAsk() {
    // If there is not options in spec it is always no options to ask
    if (this.spec && !this.spec.config) {
      return {};
    }

    const options = {};

    if (this.isDependencySocket || this.isProjectRegistryDependency) {
      if (this.remote.status === 'ok') {
        return options;
      }

      Object.keys(this.spec.config).forEach(optionName => {
        const envValue = this.getConfigOptionFromEnv(optionName);
        const option = this.spec.config[optionName];
        if (option.required && !envValue) {
          options[optionName] = option;
        }
      });
      return options;
    }

    if (this.existLocally) {
      Object.keys(this.spec.config).forEach(optionName => {
        const envValue = this.getConfigOptionFromEnv(optionName);
        const option = this.spec.config[optionName];
        if (option.required && !envValue) {
          if (!this.remote.config || !this.remote.config[optionName]) {
            options[optionName] = option;
          }
        }
      });
      return options;
    }
  }

  // Registry
  bumpVersion(bumpType) {
    const nextVersion = this.settings.bumpVersion(bumpType);
    this.spec.version = nextVersion;
    return nextVersion;
  }

  submit() {
    debug('submit');
    this.isCompatible();
    const registry = new _registry2.default();
    return registry.submitSocket(this);
  }

  // Socket dependencies
  getDeps() {
    return this.settings.getDependencies();
  }

  getDepsRegistrySockets() {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      debug(`getDepsRegistrySockets for: ${_this15.name}`);
      const registry = new _registry2.default();

      const getDeepDeps = function (deps, socketToAdd) {
        debug('getDeepDeps', deps);
        const sockets = [];
        if (socketToAdd) {
          sockets.push(socketToAdd);
        }
        return _bluebird2.default.all(sockets.concat(Object.keys(deps).map((() => {
          var _ref6 = _asyncToGenerator(function* (dependencyName) {
            debug(`processing dependency: ${dependencyName}`);
            const socket = yield registry.searchSocketByName(dependencyName, deps[dependencyName].version);
            socket.dependencyOf = socketToAdd ? socketToAdd.name : _this15.name;

            if (!_lodash2.default.isEmpty(socket.config.dependencies)) {
              return getDeepDeps(socket.config.dependencies, socket);
            }
            debug(`returning socket without dependencies ${socket.name}`);
            return _bluebird2.default.resolve(socket);
          });

          return function (_x5) {
            return _ref6.apply(this, arguments);
          };
        })())));
      };

      debug(`Defined dependencies of "${_this15.name}" to follow: ${_this15.spec.dependencies}`);
      if (_this15.spec.dependencies) {
        const arr = yield getDeepDeps(_this15.spec.dependencies);
        const depsObjects = yield _bluebird2.default.all(_lodash2.default.flatten(arr).map((() => {
          var _ref7 = _asyncToGenerator(function* (socket) {
            const createdSocket = yield Socket.get(socket.name);
            createdSocket.isDependencySocket = true;
            createdSocket.dependencyOf = [socket.dependencyOf];
            return createdSocket;
          });

          return function (_x6) {
            return _ref7.apply(this, arguments);
          };
        })()));
        _this15.dependencies = depsObjects;
      }

      return _bluebird2.default.resolve();
    })();
  }

  addDependency(socketFromRegistry) {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      const socketName = socketFromRegistry.name;
      const socketVersion = socketFromRegistry.version;
      _this16.settings.addDependency(socketName, socketVersion);
    })();
  }

  socketEnvShouldBeUpdated() {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      debug('socketEnvShouldBeUpdated');
      try {
        const resp = yield _axios2.default.request({
          url: `https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/environments/${_this17.name}/`,
          method: 'GET',
          timeout: 50000,
          headers: {
            'X-Api-Key': _session2.default.settings.account.getAuthKey()
          }
        });

        if (resp.data.metadata.checksum === _this17.getSocketNodeModulesChecksum()) {
          debug('socketEnvShouldBeUpdated', 'env is up to date');
          return false;
        }
        return 'PATCH';
      } catch (err) {
        return 'POST';
      }
    })();
  }

  getSocketSrcChecksum() {
    const files = (0, _klawSync2.default)(this.getSrcFolder(), { nodir: true });
    const checksums = {};
    files.forEach(file => {
      const fileReltivePath = file.path.replace(this.getSrcFolder(), '');
      checksums[fileReltivePath] = (0, _md2.default)(_fs2.default.readFileSync(file.path, 'utf8'));
    });
    return checksums;
  }

  isCompatible() {
    const socketMajorVersion = this.spec.version.split('.')[0];
    if (socketMajorVersion !== _session2.default.majorVersion) {
      throw new _errors.CompatibilityError(socketMajorVersion, _session2.default.majorVersion);
    }
    return true;
  }

  shouldBeUpdated() {
    debug('shouldBeUpdated');
    if (this.existLocally && this.existRemotely) {
      const files = this.remote.files;
      return Object.keys(files).some(file => {
        let filePath;

        if (file === 'socket.yml') {
          filePath = this.getSocketYMLFile();
        } else if (file.endsWith('.js')) {
          filePath = _path2.default.join(this.getCompiledScriptsFolder(), file);
        } else {
          filePath = _path2.default.join(this.getSrcFolder(), file);
        }

        const remoteChecksum = files[file].checksum;
        const localChecksum = (0, _md2.default)(_fs2.default.readFileSync(filePath));

        debug(file);
        debug(localChecksum);
        debug(remoteChecksum);
        return localChecksum !== remoteChecksum;
      });
    } else if (!this.existRemotely) {
      return true;
    } else if (this.isDependencySocket || this.isProjectRegistryDependency) {
      if (this.remote.status !== 'ok') {
        return false;
      }

      debug(`Spec version: ${this.spec.version}`);
      debug(`Remote version: ${this.getVersion()}`);
      if (this.spec.version === this.getVersion()) {
        return false;
      }
    }
  }
}

Socket.listLocal = _utils2.default.listLocal;

exports.default = Socket;
module.exports = exports['default'];
//# sourceMappingURL=sockets.js.map